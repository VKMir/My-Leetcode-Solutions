class Solution {
public:
    void merge(int low, int mid, int high, int& count, vector<int>& nums){
        int j = mid + 1;
        for(int i = low; i <= mid; i++){
            while(j <= high && (long long) nums[i] > 2LL * nums[j]) {
                j++;
            }
            count += (j - (mid + 1));
        }
        vector<int> temp;
        j = mid+1;
        int i = low;
         while(i <= mid && j <= high){
            if(nums[i] <= nums[j]){
                temp.push_back(nums[i]);
                ++i;
            }else{
                temp.push_back(nums[j]);
                ++j;
            }
         }
         while(i <= mid){
             temp.push_back(nums[i]);
                ++i;
         }
         while(j <= high){
             temp.push_back(nums[j]);
             ++j;
         }
         int index = low;
         for(int i = 0; i < temp.size(); i++){
            nums[index] = temp[i];
            ++index;
         }
    }
    void mergeSort(int low, int high, int& count, vector<int>& nums){
        if(low < high){
            int mid = low + (high - low)/2;
            mergeSort(low, mid, count, nums);
            mergeSort(mid + 1, high, count, nums);
            merge(low, mid, high, count, nums);
        }
       
    }
    int reversePairs(vector<int>& nums) {
       int n = nums.size();
       int low = 0, high = n-1;
       int count = 0;
       mergeSort(low, high, count, nums);
       return count;
    }
};


Time Complexity: O(n log n)
Space Complexity: O(n)
